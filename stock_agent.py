# -*- coding: utf-8 -*-
"""stock_agent

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Idt1Ho-ytS9IK8PC8gtEI_7JE_TgD9yh
"""

import yfinance as yf
import pandas as pd
import requests
from datetime import datetime
from urllib.parse import urlparse
import streamlit as st

class StockAnalysisAgent:
    def __init__(self):
        """Initialize the agent"""
        self.last_update = None

    def get_stock_data(self, ticker):
        """Fetch comprehensive stock data from yfinance"""
        try:
            stock = yf.Ticker(ticker)
            info = stock.info
            history = stock.history(period='1y')

            # Improved news handling with URL validation
            news = []
            try:
                if hasattr(stock, 'news') and stock.news:
                    for n in stock.news[:3]:  # Get top 3 news items
                        title = str(n.get('title', 'No title available'))
                        link = str(n.get('link', ''))
                        publisher = str(n.get('publisher', 'Unknown source'))

                        # Validate and clean URL
                        clean_link = self._clean_url(link, title)

                        news.append({
                            'title': title,
                            'link': clean_link,
                            'publisher': publisher
                        })
            except Exception as e:
                st.warning(f"News parsing error for {ticker}: {str(e)}")
                news = []

            data = {
                'current_price': stock.history(period='1d')['Close'].iloc[-1],
                'market_cap': info.get('marketCap'),
                'pe_ratio': info.get('trailingPE'),
                '52w_high': info.get('fiftyTwoWeekHigh'),
                '52w_low': info.get('fiftyTwoWeekLow'),
                'avg_volume': info.get('averageVolume'),
                'dividend_yield': info.get('dividendYield'),
                'beta': info.get('beta'),
                'recommendation': self._get_recommendation(info.get('recommendationMean')),
                'performance': self._calculate_performance(history),
                'news': news
            }
            self.last_update = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            return data
        except Exception as e:
            st.error(f"Error fetching data for {ticker}: {str(e)}")
            return None

    def _clean_url(self, url, title):
        """Clean and validate URLs, fallback to Google search if invalid"""
        try:
            parsed = urlparse(url)
            if all([parsed.scheme, parsed.netloc]) and not parsed.netloc.startswith('localhost'):
                return url
            return f"https://www.google.com/search?q={requests.utils.quote(title)}"
        except:
            return f"https://www.google.com/search?q={requests.utils.quote(title)}"

    def _format_number(self, num):
        """Format large numbers for readability"""
        if num is None:
            return 'N/A'
        try:
            num = float(num)
            if num >= 1e12:
                return f"${num/1e12:.2f}T"
            if num >= 1e9:
                return f"${num/1e9:.2f}B"
            if num >= 1e6:
                return f"${num/1e6:.2f}M"
            return f"${num:,.2f}"
        except:
            return 'N/A'

    def _get_recommendation(self, score):
        """Convert numeric recommendation to text"""
        if score is None:
            return "N/A"
        try:
            score = float(score)
            if score <= 1.5:
                return "Strong Buy"
            elif score <= 2.5:
                return "Buy"
            elif score <= 3.5:
                return "Hold"
            elif score <= 4.5:
                return "Sell"
            else:
                return "Strong Sell"
        except:
            return "N/A"

    def _calculate_performance(self, history):
        """Calculate yearly performance percentage"""
        if len(history) < 2:
            return "N/A"
        start = history['Close'].iloc[0]
        end = history['Close'].iloc[-1]
        change = ((end - start) / start) * 100
        return f"{change:.2f}%"

    def generate_comparison(self, ticker1, ticker2):
        """Generate comparison report"""
        data1 = self.get_stock_data(ticker1)
        data2 = self.get_stock_data(ticker2)

        if not data1 or not data2:
            return None

        # Prepare comparison data
        metrics = [
            ('Current Price', 'current_price', lambda x: f"${x:,.2f}"),
            ('Market Cap', 'market_cap', self._format_number),
            ('P/E Ratio', 'pe_ratio', lambda x: f"{x:.2f}" if x else 'N/A'),
            ('52W High', '52w_high', lambda x: f"${x:,.2f}" if x else 'N/A'),
            ('52W Low', '52w_low', lambda x: f"${x:,.2f}" if x else 'N/A'),
            ('Avg Volume', 'avg_volume', self._format_number),
            ('Dividend Yield', 'dividend_yield', lambda x: f"{x*100:.2f}%" if x else 'N/A'),
            ('Beta', 'beta', lambda x: f"{x:.2f}" if x else 'N/A'),
            ('Analyst Recommendation', 'recommendation', str),
            ('1Y Performance', 'performance', str)
        ]

        comparison = {
            'Metric': [m[0] for m in metrics],
            ticker1: [m[2](data1[m[1]]) for m in metrics],
            ticker2: [m[2](data2[m[1]]) for m in metrics]
        }

        return {
            'table': pd.DataFrame(comparison),
            'news': {
                ticker1: data1['news'],
                ticker2: data2['news']
            },
            'last_update': self.last_update
        }